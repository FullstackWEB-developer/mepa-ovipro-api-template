import { StartedTestContainer } from 'testcontainers';
import { Connection } from 'typeorm';
import { createConnectionForTests, Props } from '../../../../../utils/__tests__/db/test-connection';
import { executeSchemaSetup, setUpTestContainer } from '../../../../../utils/__tests__/db/test-container';
import { ConnectionFactory } from '../../../../../utils/dao/typeorm/ConnectionFactory';
import { SimpleOffice } from '../../../model/entities/SimpleOffice';

import { officeDAO } from '../OfficeDAO';

//
// This is an example for building DB (PostgreSQL in this case) integration tests. These tests rely on a DB setupped with
// testcontainers-node (Docker).
//

/**
 * This test file implements smoke tests for the DB. These are the most simple form of DB tests
 * whose purpose is to verify that ORM schema entities and DB connections are configured properly.
 * The tests use https://github.com/testcontainers/testcontainers-node that is used to set up
 * dependencies via Docker. In this instance we set up a PostgreSQL database in a container
 * and run queries against that. Testcontainers is responsible for starting up and shutting
 * down the images. Tests are responsible for data population and cleanup between tests.
 */
describe('ConnectionSmoke', () => {
    ConnectionFactory.getConnection = jest.fn();
    jest.setTimeout(60_000);
    let container: StartedTestContainer;
    let config: Props;

    beforeAll(async () => {
        // Get a handle on the container and config for connections.
        const { container: localContainer, config: localConfig } = await setUpTestContainer();
        container = localContainer;
        config = { ...localConfig };
    });

    afterAll(async () => {
        await container.stop();
        const connection = await ConnectionFactory.getConnection();
        // Closing the connection is not needed with testcontainers.
        // If you have a persistent DB running then closing the connections is a good idea.
        await connection.close();
    });

    beforeEach(async () => {
        await executeSchemaSetup(container);
        const connection: Promise<Connection> = createConnectionForTests({ ...config });
        jest.mocked(ConnectionFactory.getConnection).mockResolvedValue(connection);
        await (
            await connection
        ).manager.query(
            `create table simple_office ( id bigint primary key generated by default as identity, public_id uuid NOT NULL unique default uuid_generate_v4());`,
        );
    });

    afterEach(async () => {
        const connection: Promise<Connection> = createConnectionForTests({ ...config });
        jest.mocked(ConnectionFactory.getConnection).mockResolvedValue(connection);
        await (await connection).manager.query(`drop table if exists simple_office;`);
    });

    test('Find Office', async () => {
        const result = await officeDAO.findOneByPublicId('c3827e39-58d5-493b-8216-b9535eed1917');
        expect(result).toBeUndefined();
    });

    test('Insert Office', async () => {
        const office = new SimpleOffice();
        office.publicId = '351ba7bb-c79a-49b7-927c-87398500f180';
        const result = await officeDAO.insert(office);
        // Generated by a sequence, the id will be 1.
        expect(result).toEqual('1');
    });
});
